"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_sanity_client_dist__chunks_stegaEncodeSourceMap_js"],{

/***/ "./node_modules/@sanity/client/dist/_chunks/stegaEncodeSourceMap.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@sanity/client/dist/_chunks/stegaEncodeSourceMap.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: function() { return /* binding */ stegaEncodeSourceMap$1; },\n/* harmony export */   e: function() { return /* binding */ encodeIntoResult; },\n/* harmony export */   s: function() { return /* binding */ stegaEncodeSourceMap; }\n/* harmony export */ });\n/* harmony import */ var _browserMiddleware_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./browserMiddleware.js */ \"./node_modules/@sanity/client/dist/_chunks/browserMiddleware.js\");\n\nconst reKeySegment = /_key\\s*==\\s*['\"](.*)['\"]/;\nfunction isKeySegment(segment) {\n  return typeof segment == \"string\" ? reKeySegment.test(segment.trim()) : typeof segment == \"object\" && \"_key\" in segment;\n}\nfunction toString(path) {\n  if (!Array.isArray(path))\n    throw new Error(\"Path is not an array\");\n  return path.reduce((target, segment, i) => {\n    const segmentType = typeof segment;\n    if (segmentType === \"number\")\n      return `${target}[${segment}]`;\n    if (segmentType === \"string\")\n      return `${target}${i === 0 ? \"\" : \".\"}${segment}`;\n    if (isKeySegment(segment) && segment._key)\n      return `${target}[_key==\"${segment._key}\"]`;\n    if (Array.isArray(segment)) {\n      const [from, to] = segment;\n      return `${target}[${from}:${to}]`;\n    }\n    throw new Error(`Unsupported path segment \\`${JSON.stringify(segment)}\\``);\n  }, \"\");\n}\nconst ESCAPE = {\n  \"\\f\": \"\\\\f\",\n  \"\\n\": \"\\\\n\",\n  \"\\r\": \"\\\\r\",\n  \"\t\": \"\\\\t\",\n  \"'\": \"\\\\'\",\n  \"\\\\\": \"\\\\\\\\\"\n}, UNESCAPE = {\n  \"\\\\f\": \"\\f\",\n  \"\\\\n\": `\n`,\n  \"\\\\r\": \"\\r\",\n  \"\\\\t\": \"\t\",\n  \"\\\\'\": \"'\",\n  \"\\\\\\\\\": \"\\\\\"\n};\nfunction jsonPath(path) {\n  return `$${path.map((segment) => typeof segment == \"string\" ? `['${segment.replace(/[\\f\\n\\r\\t'\\\\]/g, (match) => ESCAPE[match])}']` : typeof segment == \"number\" ? `[${segment}]` : segment._key !== \"\" ? `[?(@._key=='${segment._key.replace(/['\\\\]/g, (match) => ESCAPE[match])}')]` : `[${segment._index}]`).join(\"\")}`;\n}\nfunction parseJsonPath(path) {\n  const parsed = [], parseRe = /\\['(.*?)'\\]|\\[(\\d+)\\]|\\[\\?\\(@\\._key=='(.*?)'\\)\\]/g;\n  let match;\n  for (; (match = parseRe.exec(path)) !== null; ) {\n    if (match[1] !== void 0) {\n      const key = match[1].replace(/\\\\(\\\\|f|n|r|t|')/g, (m) => UNESCAPE[m]);\n      parsed.push(key);\n      continue;\n    }\n    if (match[2] !== void 0) {\n      parsed.push(parseInt(match[2], 10));\n      continue;\n    }\n    if (match[3] !== void 0) {\n      const _key = match[3].replace(/\\\\(\\\\')/g, (m) => UNESCAPE[m]);\n      parsed.push({\n        _key,\n        _index: -1\n      });\n      continue;\n    }\n  }\n  return parsed;\n}\nfunction jsonPathToStudioPath(path) {\n  return path.map((segment) => {\n    if (typeof segment == \"string\" || typeof segment == \"number\")\n      return segment;\n    if (segment._key !== \"\")\n      return { _key: segment._key };\n    if (segment._index !== -1)\n      return segment._index;\n    throw new Error(`invalid segment:${JSON.stringify(segment)}`);\n  });\n}\nfunction jsonPathToMappingPath(path) {\n  return path.map((segment) => {\n    if (typeof segment == \"string\" || typeof segment == \"number\")\n      return segment;\n    if (segment._index !== -1)\n      return segment._index;\n    throw new Error(`invalid segment:${JSON.stringify(segment)}`);\n  });\n}\nfunction resolveMapping(resultPath, csm) {\n  if (!(csm != null && csm.mappings))\n    return;\n  const resultMappingPath = jsonPath(jsonPathToMappingPath(resultPath));\n  if (csm.mappings[resultMappingPath] !== void 0)\n    return {\n      mapping: csm.mappings[resultMappingPath],\n      matchedPath: resultMappingPath,\n      pathSuffix: \"\"\n    };\n  const mappings = Object.entries(csm.mappings).filter(([key]) => resultMappingPath.startsWith(key)).sort(([key1], [key2]) => key2.length - key1.length);\n  if (mappings.length == 0)\n    return;\n  const [matchedPath, mapping] = mappings[0], pathSuffix = resultMappingPath.substring(matchedPath.length);\n  return { mapping, matchedPath, pathSuffix };\n}\nfunction isArray(value) {\n  return value !== null && Array.isArray(value);\n}\nfunction isRecord(value) {\n  return typeof value == \"object\" && value !== null;\n}\nfunction walkMap(value, mappingFn, path = []) {\n  return isArray(value) ? value.map((v, idx) => {\n    if (isRecord(v)) {\n      const _key = v._key;\n      if (typeof _key == \"string\")\n        return walkMap(v, mappingFn, path.concat({ _key, _index: idx }));\n    }\n    return walkMap(v, mappingFn, path.concat(idx));\n  }) : isRecord(value) ? Object.fromEntries(\n    Object.entries(value).map(([k, v]) => [k, walkMap(v, mappingFn, path.concat(k))])\n  ) : mappingFn(value, path);\n}\nfunction encodeIntoResult(result, csm, encoder) {\n  return walkMap(result, (value, path) => {\n    if (typeof value != \"string\")\n      return value;\n    const resolveMappingResult = resolveMapping(path, csm);\n    if (!resolveMappingResult)\n      return value;\n    const { mapping, matchedPath } = resolveMappingResult;\n    if (mapping.type !== \"value\" || mapping.source.type !== \"documentValue\")\n      return value;\n    const sourceDocument = csm.documents[mapping.source.document], sourcePath = csm.paths[mapping.source.path], matchPathSegments = parseJsonPath(matchedPath), fullSourceSegments = parseJsonPath(sourcePath).concat(path.slice(matchPathSegments.length));\n    return encoder({\n      sourcePath: fullSourceSegments,\n      sourceDocument,\n      resultPath: path,\n      value\n    });\n  });\n}\nconst DRAFTS_PREFIX = \"drafts.\";\nfunction getPublishedId(id) {\n  return id.startsWith(DRAFTS_PREFIX) ? id.slice(DRAFTS_PREFIX.length) : id;\n}\nfunction createEditUrl(options) {\n  const {\n    baseUrl,\n    workspace: _workspace = \"default\",\n    tool: _tool = \"default\",\n    id: _id,\n    type,\n    path,\n    projectId,\n    dataset\n  } = options;\n  if (!baseUrl)\n    throw new Error(\"baseUrl is required\");\n  if (!path)\n    throw new Error(\"path is required\");\n  if (!_id)\n    throw new Error(\"id is required\");\n  if (baseUrl !== \"/\" && baseUrl.endsWith(\"/\"))\n    throw new Error(\"baseUrl must not end with a slash\");\n  const workspace = _workspace === \"default\" ? void 0 : _workspace, tool = _tool === \"default\" ? void 0 : _tool, id = getPublishedId(_id), stringifiedPath = Array.isArray(path) ? toString(jsonPathToStudioPath(path)) : path, searchParams = new URLSearchParams({\n    baseUrl,\n    id,\n    type,\n    path: stringifiedPath\n  });\n  workspace && searchParams.set(\"workspace\", workspace), tool && searchParams.set(\"tool\", tool), projectId && searchParams.set(\"projectId\", projectId), dataset && searchParams.set(\"dataset\", dataset), _id.startsWith(DRAFTS_PREFIX) && searchParams.set(\"isDraft\", \"\");\n  const segments = [baseUrl === \"/\" ? \"\" : baseUrl];\n  workspace && segments.push(workspace);\n  const routerParams = [\n    \"mode=presentation\",\n    `id=${id}`,\n    `type=${type}`,\n    `path=${encodeURIComponent(stringifiedPath)}`\n  ];\n  return tool && routerParams.push(`tool=${tool}`), segments.push(\"intent\", \"edit\", `${routerParams.join(\";\")}?${searchParams}`), segments.join(\"/\");\n}\nfunction resolveStudioBaseRoute(studioUrl) {\n  let baseUrl = typeof studioUrl == \"string\" ? studioUrl : studioUrl.baseUrl;\n  return baseUrl !== \"/\" && (baseUrl = baseUrl.replace(/\\/$/, \"\")), typeof studioUrl == \"string\" ? { baseUrl } : { ...studioUrl, baseUrl };\n}\nconst filterDefault = ({ sourcePath, value }) => {\n  if (isValidDate(value) || isValidURL(value))\n    return !1;\n  const endPath = sourcePath.at(-1);\n  return !(sourcePath.at(-2) === \"slug\" && endPath === \"current\" || typeof endPath == \"string\" && endPath.startsWith(\"_\") || typeof endPath == \"number\" && sourcePath.at(-2) === \"marks\" || endPath === \"href\" && typeof sourcePath.at(-2) == \"number\" && sourcePath.at(-3) === \"markDefs\" || endPath === \"style\" || endPath === \"listItem\" || sourcePath.some(\n    (path) => path === \"meta\" || path === \"metadata\" || path === \"openGraph\" || path === \"seo\"\n  ) || typeof endPath == \"string\" && denylist.has(endPath));\n}, denylist = /* @__PURE__ */ new Set([\n  \"color\",\n  \"colour\",\n  \"currency\",\n  \"email\",\n  \"format\",\n  \"gid\",\n  \"hex\",\n  \"href\",\n  \"hsl\",\n  \"hsla\",\n  \"icon\",\n  \"id\",\n  \"index\",\n  \"key\",\n  \"language\",\n  \"layout\",\n  \"link\",\n  \"linkAction\",\n  \"locale\",\n  \"lqip\",\n  \"page\",\n  \"path\",\n  \"ref\",\n  \"rgb\",\n  \"rgba\",\n  \"route\",\n  \"secret\",\n  \"slug\",\n  \"status\",\n  \"tag\",\n  \"template\",\n  \"theme\",\n  \"type\",\n  \"unit\",\n  \"url\",\n  \"username\",\n  \"variant\",\n  \"website\"\n]);\nfunction isValidDate(dateString) {\n  return /^\\d{4}-\\d{2}-\\d{2}/.test(dateString) ? !!Date.parse(dateString) : !1;\n}\nfunction isValidURL(url) {\n  try {\n    new URL(url, url.startsWith(\"/\") ? \"https://acme.com\" : void 0);\n  } catch {\n    return !1;\n  }\n  return !0;\n}\nconst TRUNCATE_LENGTH = 20;\nfunction stegaEncodeSourceMap(result, resultSourceMap, config) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _i;\n  const { filter, logger, enabled } = config;\n  if (!enabled) {\n    const msg = \"config.enabled must be true, don't call this function otherwise\";\n    throw (_a = logger == null ? void 0 : logger.error) == null || _a.call(logger, `[@sanity/client]: ${msg}`, { result, resultSourceMap, config }), new TypeError(msg);\n  }\n  if (!resultSourceMap)\n    return (_b = logger == null ? void 0 : logger.error) == null || _b.call(logger, \"[@sanity/client]: Missing Content Source Map from response body\", {\n      result,\n      resultSourceMap,\n      config\n    }), result;\n  if (!config.studioUrl) {\n    const msg = \"config.studioUrl must be defined\";\n    throw (_c = logger == null ? void 0 : logger.error) == null || _c.call(logger, `[@sanity/client]: ${msg}`, { result, resultSourceMap, config }), new TypeError(msg);\n  }\n  const report = {\n    encoded: [],\n    skipped: []\n  }, resultWithStega = encodeIntoResult(\n    result,\n    resultSourceMap,\n    ({ sourcePath, sourceDocument, resultPath, value }) => {\n      if ((typeof filter == \"function\" ? filter({ sourcePath, resultPath, filterDefault, sourceDocument, value }) : filterDefault({ sourcePath, resultPath, filterDefault, sourceDocument, value })) === !1)\n        return logger && report.skipped.push({\n          path: prettyPathForLogging(sourcePath),\n          value: `${value.slice(0, TRUNCATE_LENGTH)}${value.length > TRUNCATE_LENGTH ? \"...\" : \"\"}`,\n          length: value.length\n        }), value;\n      logger && report.encoded.push({\n        path: prettyPathForLogging(sourcePath),\n        value: `${value.slice(0, TRUNCATE_LENGTH)}${value.length > TRUNCATE_LENGTH ? \"...\" : \"\"}`,\n        length: value.length\n      });\n      const { baseUrl, workspace, tool } = resolveStudioBaseRoute(\n        typeof config.studioUrl == \"function\" ? config.studioUrl(sourceDocument) : config.studioUrl\n      );\n      if (!baseUrl)\n        return value;\n      const { _id: id, _type: type, _projectId: projectId, _dataset: dataset } = sourceDocument;\n      return (0,_browserMiddleware_js__WEBPACK_IMPORTED_MODULE_0__.g)(\n        value,\n        {\n          origin: \"sanity.io\",\n          href: createEditUrl({\n            baseUrl,\n            workspace,\n            tool,\n            id,\n            type,\n            path: sourcePath,\n            ...!config.omitCrossDatasetReferenceData && { dataset, projectId }\n          })\n        },\n        // We use custom logic to determine if we should skip encoding\n        !1\n      );\n    }\n  );\n  if (logger) {\n    const isSkipping = report.skipped.length, isEncoding = report.encoded.length;\n    if ((isSkipping || isEncoding) && ((_d = (logger == null ? void 0 : logger.groupCollapsed) || logger.log) == null || _d(\"[@sanity/client]: Encoding source map into result\"), (_e = logger.log) == null || _e.call(\n      logger,\n      `[@sanity/client]: Paths encoded: ${report.encoded.length}, skipped: ${report.skipped.length}`\n    )), report.encoded.length > 0 && ((_f = logger == null ? void 0 : logger.log) == null || _f.call(logger, \"[@sanity/client]: Table of encoded paths\"), (_g = (logger == null ? void 0 : logger.table) || logger.log) == null || _g(report.encoded)), report.skipped.length > 0) {\n      const skipped = /* @__PURE__ */ new Set();\n      for (const { path } of report.skipped)\n        skipped.add(path.replace(reKeySegment, \"0\").replace(/\\[\\d+\\]/g, \"[]\"));\n      (_h = logger == null ? void 0 : logger.log) == null || _h.call(logger, \"[@sanity/client]: List of skipped paths\", [...skipped.values()]);\n    }\n    (isSkipping || isEncoding) && ((_i = logger == null ? void 0 : logger.groupEnd) == null || _i.call(logger));\n  }\n  return resultWithStega;\n}\nfunction prettyPathForLogging(path) {\n  return toString(jsonPathToStudioPath(path));\n}\nvar stegaEncodeSourceMap$1 = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  stegaEncodeSourceMap\n});\n\n//# sourceMappingURL=stegaEncodeSourceMap.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNhbml0eS9jbGllbnQvZGlzdC9fY2h1bmtzL3N0ZWdhRW5jb2RlU291cmNlTWFwLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTyxHQUFHLFFBQVE7QUFDbEM7QUFDQSxnQkFBZ0IsT0FBTyxFQUFFLG1CQUFtQixFQUFFLFFBQVE7QUFDdEQ7QUFDQSxnQkFBZ0IsT0FBTyxVQUFVLGFBQWE7QUFDOUM7QUFDQTtBQUNBLGdCQUFnQixPQUFPLEdBQUcsS0FBSyxHQUFHLEdBQUc7QUFDckM7QUFDQSxrREFBa0Qsd0JBQXdCO0FBQzFFLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0RBQXdELDREQUE0RCx1Q0FBdUMsUUFBUSwwQ0FBMEMseURBQXlELFdBQVcsZUFBZSxhQUFhO0FBQzFUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx1Q0FBdUM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsdUNBQXVDLHdCQUF3QjtBQUMvRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsd0JBQXdCO0FBQy9ELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELG1CQUFtQjtBQUN0RTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLEdBQUc7QUFDYixZQUFZLEtBQUs7QUFDakIsWUFBWSxvQ0FBb0M7QUFDaEQ7QUFDQSwyQ0FBMkMsS0FBSyx1Q0FBdUMsb0JBQW9CLEdBQUcsR0FBRyxhQUFhO0FBQzlIO0FBQ0E7QUFDQTtBQUNBLHFHQUFxRyxVQUFVLElBQUk7QUFDbkg7QUFDQSx5QkFBeUIsbUJBQW1CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwwQkFBMEI7QUFDcEM7QUFDQTtBQUNBLHdHQUF3RyxJQUFJLEtBQUssaUNBQWlDO0FBQ2xKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0dBQXdHLElBQUksS0FBSyxpQ0FBaUM7QUFDbEo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLE9BQU8sK0NBQStDO0FBQ3RELGtEQUFrRCw4REFBOEQsb0JBQW9CLDhEQUE4RDtBQUNsTTtBQUNBO0FBQ0Esb0JBQW9CLGdDQUFnQyxFQUFFLDRDQUE0QztBQUNsRztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0JBQWtCLGdDQUFnQyxFQUFFLDRDQUE0QztBQUNoRztBQUNBLE9BQU87QUFDUCxjQUFjLDJCQUEyQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUVBQWlFO0FBQy9FLGFBQWEsd0RBQUM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRCxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxzQkFBc0IsYUFBYSxzQkFBc0I7QUFDbkc7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUtDO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvY2xpZW50L2Rpc3QvX2NodW5rcy9zdGVnYUVuY29kZVNvdXJjZU1hcC5qcz8wMzllIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGcgYXMgYiB9IGZyb20gXCIuL2Jyb3dzZXJNaWRkbGV3YXJlLmpzXCI7XG5jb25zdCByZUtleVNlZ21lbnQgPSAvX2tleVxccyo9PVxccypbJ1wiXSguKilbJ1wiXS87XG5mdW5jdGlvbiBpc0tleVNlZ21lbnQoc2VnbWVudCkge1xuICByZXR1cm4gdHlwZW9mIHNlZ21lbnQgPT0gXCJzdHJpbmdcIiA/IHJlS2V5U2VnbWVudC50ZXN0KHNlZ21lbnQudHJpbSgpKSA6IHR5cGVvZiBzZWdtZW50ID09IFwib2JqZWN0XCIgJiYgXCJfa2V5XCIgaW4gc2VnbWVudDtcbn1cbmZ1bmN0aW9uIHRvU3RyaW5nKHBhdGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHBhdGgpKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlBhdGggaXMgbm90IGFuIGFycmF5XCIpO1xuICByZXR1cm4gcGF0aC5yZWR1Y2UoKHRhcmdldCwgc2VnbWVudCwgaSkgPT4ge1xuICAgIGNvbnN0IHNlZ21lbnRUeXBlID0gdHlwZW9mIHNlZ21lbnQ7XG4gICAgaWYgKHNlZ21lbnRUeXBlID09PSBcIm51bWJlclwiKVxuICAgICAgcmV0dXJuIGAke3RhcmdldH1bJHtzZWdtZW50fV1gO1xuICAgIGlmIChzZWdtZW50VHlwZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiBgJHt0YXJnZXR9JHtpID09PSAwID8gXCJcIiA6IFwiLlwifSR7c2VnbWVudH1gO1xuICAgIGlmIChpc0tleVNlZ21lbnQoc2VnbWVudCkgJiYgc2VnbWVudC5fa2V5KVxuICAgICAgcmV0dXJuIGAke3RhcmdldH1bX2tleT09XCIke3NlZ21lbnQuX2tleX1cIl1gO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHNlZ21lbnQpKSB7XG4gICAgICBjb25zdCBbZnJvbSwgdG9dID0gc2VnbWVudDtcbiAgICAgIHJldHVybiBgJHt0YXJnZXR9WyR7ZnJvbX06JHt0b31dYDtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBwYXRoIHNlZ21lbnQgXFxgJHtKU09OLnN0cmluZ2lmeShzZWdtZW50KX1cXGBgKTtcbiAgfSwgXCJcIik7XG59XG5jb25zdCBFU0NBUEUgPSB7XG4gIFwiXFxmXCI6IFwiXFxcXGZcIixcbiAgXCJcXG5cIjogXCJcXFxcblwiLFxuICBcIlxcclwiOiBcIlxcXFxyXCIsXG4gIFwiXHRcIjogXCJcXFxcdFwiLFxuICBcIidcIjogXCJcXFxcJ1wiLFxuICBcIlxcXFxcIjogXCJcXFxcXFxcXFwiXG59LCBVTkVTQ0FQRSA9IHtcbiAgXCJcXFxcZlwiOiBcIlxcZlwiLFxuICBcIlxcXFxuXCI6IGBcbmAsXG4gIFwiXFxcXHJcIjogXCJcXHJcIixcbiAgXCJcXFxcdFwiOiBcIlx0XCIsXG4gIFwiXFxcXCdcIjogXCInXCIsXG4gIFwiXFxcXFxcXFxcIjogXCJcXFxcXCJcbn07XG5mdW5jdGlvbiBqc29uUGF0aChwYXRoKSB7XG4gIHJldHVybiBgJCR7cGF0aC5tYXAoKHNlZ21lbnQpID0+IHR5cGVvZiBzZWdtZW50ID09IFwic3RyaW5nXCIgPyBgWycke3NlZ21lbnQucmVwbGFjZSgvW1xcZlxcblxcclxcdCdcXFxcXS9nLCAobWF0Y2gpID0+IEVTQ0FQRVttYXRjaF0pfSddYCA6IHR5cGVvZiBzZWdtZW50ID09IFwibnVtYmVyXCIgPyBgWyR7c2VnbWVudH1dYCA6IHNlZ21lbnQuX2tleSAhPT0gXCJcIiA/IGBbPyhALl9rZXk9PScke3NlZ21lbnQuX2tleS5yZXBsYWNlKC9bJ1xcXFxdL2csIChtYXRjaCkgPT4gRVNDQVBFW21hdGNoXSl9JyldYCA6IGBbJHtzZWdtZW50Ll9pbmRleH1dYCkuam9pbihcIlwiKX1gO1xufVxuZnVuY3Rpb24gcGFyc2VKc29uUGF0aChwYXRoKSB7XG4gIGNvbnN0IHBhcnNlZCA9IFtdLCBwYXJzZVJlID0gL1xcWycoLio/KSdcXF18XFxbKFxcZCspXFxdfFxcW1xcP1xcKEBcXC5fa2V5PT0nKC4qPyknXFwpXFxdL2c7XG4gIGxldCBtYXRjaDtcbiAgZm9yICg7IChtYXRjaCA9IHBhcnNlUmUuZXhlYyhwYXRoKSkgIT09IG51bGw7ICkge1xuICAgIGlmIChtYXRjaFsxXSAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBrZXkgPSBtYXRjaFsxXS5yZXBsYWNlKC9cXFxcKFxcXFx8ZnxufHJ8dHwnKS9nLCAobSkgPT4gVU5FU0NBUEVbbV0pO1xuICAgICAgcGFyc2VkLnB1c2goa2V5KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobWF0Y2hbMl0gIT09IHZvaWQgMCkge1xuICAgICAgcGFyc2VkLnB1c2gocGFyc2VJbnQobWF0Y2hbMl0sIDEwKSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG1hdGNoWzNdICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IF9rZXkgPSBtYXRjaFszXS5yZXBsYWNlKC9cXFxcKFxcXFwnKS9nLCAobSkgPT4gVU5FU0NBUEVbbV0pO1xuICAgICAgcGFyc2VkLnB1c2goe1xuICAgICAgICBfa2V5LFxuICAgICAgICBfaW5kZXg6IC0xXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGFyc2VkO1xufVxuZnVuY3Rpb24ganNvblBhdGhUb1N0dWRpb1BhdGgocGF0aCkge1xuICByZXR1cm4gcGF0aC5tYXAoKHNlZ21lbnQpID0+IHtcbiAgICBpZiAodHlwZW9mIHNlZ21lbnQgPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2Ygc2VnbWVudCA9PSBcIm51bWJlclwiKVxuICAgICAgcmV0dXJuIHNlZ21lbnQ7XG4gICAgaWYgKHNlZ21lbnQuX2tleSAhPT0gXCJcIilcbiAgICAgIHJldHVybiB7IF9rZXk6IHNlZ21lbnQuX2tleSB9O1xuICAgIGlmIChzZWdtZW50Ll9pbmRleCAhPT0gLTEpXG4gICAgICByZXR1cm4gc2VnbWVudC5faW5kZXg7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHNlZ21lbnQ6JHtKU09OLnN0cmluZ2lmeShzZWdtZW50KX1gKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBqc29uUGF0aFRvTWFwcGluZ1BhdGgocGF0aCkge1xuICByZXR1cm4gcGF0aC5tYXAoKHNlZ21lbnQpID0+IHtcbiAgICBpZiAodHlwZW9mIHNlZ21lbnQgPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2Ygc2VnbWVudCA9PSBcIm51bWJlclwiKVxuICAgICAgcmV0dXJuIHNlZ21lbnQ7XG4gICAgaWYgKHNlZ21lbnQuX2luZGV4ICE9PSAtMSlcbiAgICAgIHJldHVybiBzZWdtZW50Ll9pbmRleDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgc2VnbWVudDoke0pTT04uc3RyaW5naWZ5KHNlZ21lbnQpfWApO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVNYXBwaW5nKHJlc3VsdFBhdGgsIGNzbSkge1xuICBpZiAoIShjc20gIT0gbnVsbCAmJiBjc20ubWFwcGluZ3MpKVxuICAgIHJldHVybjtcbiAgY29uc3QgcmVzdWx0TWFwcGluZ1BhdGggPSBqc29uUGF0aChqc29uUGF0aFRvTWFwcGluZ1BhdGgocmVzdWx0UGF0aCkpO1xuICBpZiAoY3NtLm1hcHBpbmdzW3Jlc3VsdE1hcHBpbmdQYXRoXSAhPT0gdm9pZCAwKVxuICAgIHJldHVybiB7XG4gICAgICBtYXBwaW5nOiBjc20ubWFwcGluZ3NbcmVzdWx0TWFwcGluZ1BhdGhdLFxuICAgICAgbWF0Y2hlZFBhdGg6IHJlc3VsdE1hcHBpbmdQYXRoLFxuICAgICAgcGF0aFN1ZmZpeDogXCJcIlxuICAgIH07XG4gIGNvbnN0IG1hcHBpbmdzID0gT2JqZWN0LmVudHJpZXMoY3NtLm1hcHBpbmdzKS5maWx0ZXIoKFtrZXldKSA9PiByZXN1bHRNYXBwaW5nUGF0aC5zdGFydHNXaXRoKGtleSkpLnNvcnQoKFtrZXkxXSwgW2tleTJdKSA9PiBrZXkyLmxlbmd0aCAtIGtleTEubGVuZ3RoKTtcbiAgaWYgKG1hcHBpbmdzLmxlbmd0aCA9PSAwKVxuICAgIHJldHVybjtcbiAgY29uc3QgW21hdGNoZWRQYXRoLCBtYXBwaW5nXSA9IG1hcHBpbmdzWzBdLCBwYXRoU3VmZml4ID0gcmVzdWx0TWFwcGluZ1BhdGguc3Vic3RyaW5nKG1hdGNoZWRQYXRoLmxlbmd0aCk7XG4gIHJldHVybiB7IG1hcHBpbmcsIG1hdGNoZWRQYXRoLCBwYXRoU3VmZml4IH07XG59XG5mdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzUmVjb3JkKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cbmZ1bmN0aW9uIHdhbGtNYXAodmFsdWUsIG1hcHBpbmdGbiwgcGF0aCA9IFtdKSB7XG4gIHJldHVybiBpc0FycmF5KHZhbHVlKSA/IHZhbHVlLm1hcCgodiwgaWR4KSA9PiB7XG4gICAgaWYgKGlzUmVjb3JkKHYpKSB7XG4gICAgICBjb25zdCBfa2V5ID0gdi5fa2V5O1xuICAgICAgaWYgKHR5cGVvZiBfa2V5ID09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiB3YWxrTWFwKHYsIG1hcHBpbmdGbiwgcGF0aC5jb25jYXQoeyBfa2V5LCBfaW5kZXg6IGlkeCB9KSk7XG4gICAgfVxuICAgIHJldHVybiB3YWxrTWFwKHYsIG1hcHBpbmdGbiwgcGF0aC5jb25jYXQoaWR4KSk7XG4gIH0pIDogaXNSZWNvcmQodmFsdWUpID8gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIE9iamVjdC5lbnRyaWVzKHZhbHVlKS5tYXAoKFtrLCB2XSkgPT4gW2ssIHdhbGtNYXAodiwgbWFwcGluZ0ZuLCBwYXRoLmNvbmNhdChrKSldKVxuICApIDogbWFwcGluZ0ZuKHZhbHVlLCBwYXRoKTtcbn1cbmZ1bmN0aW9uIGVuY29kZUludG9SZXN1bHQocmVzdWx0LCBjc20sIGVuY29kZXIpIHtcbiAgcmV0dXJuIHdhbGtNYXAocmVzdWx0LCAodmFsdWUsIHBhdGgpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgY29uc3QgcmVzb2x2ZU1hcHBpbmdSZXN1bHQgPSByZXNvbHZlTWFwcGluZyhwYXRoLCBjc20pO1xuICAgIGlmICghcmVzb2x2ZU1hcHBpbmdSZXN1bHQpXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgY29uc3QgeyBtYXBwaW5nLCBtYXRjaGVkUGF0aCB9ID0gcmVzb2x2ZU1hcHBpbmdSZXN1bHQ7XG4gICAgaWYgKG1hcHBpbmcudHlwZSAhPT0gXCJ2YWx1ZVwiIHx8IG1hcHBpbmcuc291cmNlLnR5cGUgIT09IFwiZG9jdW1lbnRWYWx1ZVwiKVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGNvbnN0IHNvdXJjZURvY3VtZW50ID0gY3NtLmRvY3VtZW50c1ttYXBwaW5nLnNvdXJjZS5kb2N1bWVudF0sIHNvdXJjZVBhdGggPSBjc20ucGF0aHNbbWFwcGluZy5zb3VyY2UucGF0aF0sIG1hdGNoUGF0aFNlZ21lbnRzID0gcGFyc2VKc29uUGF0aChtYXRjaGVkUGF0aCksIGZ1bGxTb3VyY2VTZWdtZW50cyA9IHBhcnNlSnNvblBhdGgoc291cmNlUGF0aCkuY29uY2F0KHBhdGguc2xpY2UobWF0Y2hQYXRoU2VnbWVudHMubGVuZ3RoKSk7XG4gICAgcmV0dXJuIGVuY29kZXIoe1xuICAgICAgc291cmNlUGF0aDogZnVsbFNvdXJjZVNlZ21lbnRzLFxuICAgICAgc291cmNlRG9jdW1lbnQsXG4gICAgICByZXN1bHRQYXRoOiBwYXRoLFxuICAgICAgdmFsdWVcbiAgICB9KTtcbiAgfSk7XG59XG5jb25zdCBEUkFGVFNfUFJFRklYID0gXCJkcmFmdHMuXCI7XG5mdW5jdGlvbiBnZXRQdWJsaXNoZWRJZChpZCkge1xuICByZXR1cm4gaWQuc3RhcnRzV2l0aChEUkFGVFNfUFJFRklYKSA/IGlkLnNsaWNlKERSQUZUU19QUkVGSVgubGVuZ3RoKSA6IGlkO1xufVxuZnVuY3Rpb24gY3JlYXRlRWRpdFVybChvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBiYXNlVXJsLFxuICAgIHdvcmtzcGFjZTogX3dvcmtzcGFjZSA9IFwiZGVmYXVsdFwiLFxuICAgIHRvb2w6IF90b29sID0gXCJkZWZhdWx0XCIsXG4gICAgaWQ6IF9pZCxcbiAgICB0eXBlLFxuICAgIHBhdGgsXG4gICAgcHJvamVjdElkLFxuICAgIGRhdGFzZXRcbiAgfSA9IG9wdGlvbnM7XG4gIGlmICghYmFzZVVybClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYXNlVXJsIGlzIHJlcXVpcmVkXCIpO1xuICBpZiAoIXBhdGgpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwicGF0aCBpcyByZXF1aXJlZFwiKTtcbiAgaWYgKCFfaWQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaWQgaXMgcmVxdWlyZWRcIik7XG4gIGlmIChiYXNlVXJsICE9PSBcIi9cIiAmJiBiYXNlVXJsLmVuZHNXaXRoKFwiL1wiKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYXNlVXJsIG11c3Qgbm90IGVuZCB3aXRoIGEgc2xhc2hcIik7XG4gIGNvbnN0IHdvcmtzcGFjZSA9IF93b3Jrc3BhY2UgPT09IFwiZGVmYXVsdFwiID8gdm9pZCAwIDogX3dvcmtzcGFjZSwgdG9vbCA9IF90b29sID09PSBcImRlZmF1bHRcIiA/IHZvaWQgMCA6IF90b29sLCBpZCA9IGdldFB1Ymxpc2hlZElkKF9pZCksIHN0cmluZ2lmaWVkUGF0aCA9IEFycmF5LmlzQXJyYXkocGF0aCkgPyB0b1N0cmluZyhqc29uUGF0aFRvU3R1ZGlvUGF0aChwYXRoKSkgOiBwYXRoLCBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICBiYXNlVXJsLFxuICAgIGlkLFxuICAgIHR5cGUsXG4gICAgcGF0aDogc3RyaW5naWZpZWRQYXRoXG4gIH0pO1xuICB3b3Jrc3BhY2UgJiYgc2VhcmNoUGFyYW1zLnNldChcIndvcmtzcGFjZVwiLCB3b3Jrc3BhY2UpLCB0b29sICYmIHNlYXJjaFBhcmFtcy5zZXQoXCJ0b29sXCIsIHRvb2wpLCBwcm9qZWN0SWQgJiYgc2VhcmNoUGFyYW1zLnNldChcInByb2plY3RJZFwiLCBwcm9qZWN0SWQpLCBkYXRhc2V0ICYmIHNlYXJjaFBhcmFtcy5zZXQoXCJkYXRhc2V0XCIsIGRhdGFzZXQpLCBfaWQuc3RhcnRzV2l0aChEUkFGVFNfUFJFRklYKSAmJiBzZWFyY2hQYXJhbXMuc2V0KFwiaXNEcmFmdFwiLCBcIlwiKTtcbiAgY29uc3Qgc2VnbWVudHMgPSBbYmFzZVVybCA9PT0gXCIvXCIgPyBcIlwiIDogYmFzZVVybF07XG4gIHdvcmtzcGFjZSAmJiBzZWdtZW50cy5wdXNoKHdvcmtzcGFjZSk7XG4gIGNvbnN0IHJvdXRlclBhcmFtcyA9IFtcbiAgICBcIm1vZGU9cHJlc2VudGF0aW9uXCIsXG4gICAgYGlkPSR7aWR9YCxcbiAgICBgdHlwZT0ke3R5cGV9YCxcbiAgICBgcGF0aD0ke2VuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZmllZFBhdGgpfWBcbiAgXTtcbiAgcmV0dXJuIHRvb2wgJiYgcm91dGVyUGFyYW1zLnB1c2goYHRvb2w9JHt0b29sfWApLCBzZWdtZW50cy5wdXNoKFwiaW50ZW50XCIsIFwiZWRpdFwiLCBgJHtyb3V0ZXJQYXJhbXMuam9pbihcIjtcIil9PyR7c2VhcmNoUGFyYW1zfWApLCBzZWdtZW50cy5qb2luKFwiL1wiKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVTdHVkaW9CYXNlUm91dGUoc3R1ZGlvVXJsKSB7XG4gIGxldCBiYXNlVXJsID0gdHlwZW9mIHN0dWRpb1VybCA9PSBcInN0cmluZ1wiID8gc3R1ZGlvVXJsIDogc3R1ZGlvVXJsLmJhc2VVcmw7XG4gIHJldHVybiBiYXNlVXJsICE9PSBcIi9cIiAmJiAoYmFzZVVybCA9IGJhc2VVcmwucmVwbGFjZSgvXFwvJC8sIFwiXCIpKSwgdHlwZW9mIHN0dWRpb1VybCA9PSBcInN0cmluZ1wiID8geyBiYXNlVXJsIH0gOiB7IC4uLnN0dWRpb1VybCwgYmFzZVVybCB9O1xufVxuY29uc3QgZmlsdGVyRGVmYXVsdCA9ICh7IHNvdXJjZVBhdGgsIHZhbHVlIH0pID0+IHtcbiAgaWYgKGlzVmFsaWREYXRlKHZhbHVlKSB8fCBpc1ZhbGlkVVJMKHZhbHVlKSlcbiAgICByZXR1cm4gITE7XG4gIGNvbnN0IGVuZFBhdGggPSBzb3VyY2VQYXRoLmF0KC0xKTtcbiAgcmV0dXJuICEoc291cmNlUGF0aC5hdCgtMikgPT09IFwic2x1Z1wiICYmIGVuZFBhdGggPT09IFwiY3VycmVudFwiIHx8IHR5cGVvZiBlbmRQYXRoID09IFwic3RyaW5nXCIgJiYgZW5kUGF0aC5zdGFydHNXaXRoKFwiX1wiKSB8fCB0eXBlb2YgZW5kUGF0aCA9PSBcIm51bWJlclwiICYmIHNvdXJjZVBhdGguYXQoLTIpID09PSBcIm1hcmtzXCIgfHwgZW5kUGF0aCA9PT0gXCJocmVmXCIgJiYgdHlwZW9mIHNvdXJjZVBhdGguYXQoLTIpID09IFwibnVtYmVyXCIgJiYgc291cmNlUGF0aC5hdCgtMykgPT09IFwibWFya0RlZnNcIiB8fCBlbmRQYXRoID09PSBcInN0eWxlXCIgfHwgZW5kUGF0aCA9PT0gXCJsaXN0SXRlbVwiIHx8IHNvdXJjZVBhdGguc29tZShcbiAgICAocGF0aCkgPT4gcGF0aCA9PT0gXCJtZXRhXCIgfHwgcGF0aCA9PT0gXCJtZXRhZGF0YVwiIHx8IHBhdGggPT09IFwib3BlbkdyYXBoXCIgfHwgcGF0aCA9PT0gXCJzZW9cIlxuICApIHx8IHR5cGVvZiBlbmRQYXRoID09IFwic3RyaW5nXCIgJiYgZGVueWxpc3QuaGFzKGVuZFBhdGgpKTtcbn0sIGRlbnlsaXN0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICBcImNvbG9yXCIsXG4gIFwiY29sb3VyXCIsXG4gIFwiY3VycmVuY3lcIixcbiAgXCJlbWFpbFwiLFxuICBcImZvcm1hdFwiLFxuICBcImdpZFwiLFxuICBcImhleFwiLFxuICBcImhyZWZcIixcbiAgXCJoc2xcIixcbiAgXCJoc2xhXCIsXG4gIFwiaWNvblwiLFxuICBcImlkXCIsXG4gIFwiaW5kZXhcIixcbiAgXCJrZXlcIixcbiAgXCJsYW5ndWFnZVwiLFxuICBcImxheW91dFwiLFxuICBcImxpbmtcIixcbiAgXCJsaW5rQWN0aW9uXCIsXG4gIFwibG9jYWxlXCIsXG4gIFwibHFpcFwiLFxuICBcInBhZ2VcIixcbiAgXCJwYXRoXCIsXG4gIFwicmVmXCIsXG4gIFwicmdiXCIsXG4gIFwicmdiYVwiLFxuICBcInJvdXRlXCIsXG4gIFwic2VjcmV0XCIsXG4gIFwic2x1Z1wiLFxuICBcInN0YXR1c1wiLFxuICBcInRhZ1wiLFxuICBcInRlbXBsYXRlXCIsXG4gIFwidGhlbWVcIixcbiAgXCJ0eXBlXCIsXG4gIFwidW5pdFwiLFxuICBcInVybFwiLFxuICBcInVzZXJuYW1lXCIsXG4gIFwidmFyaWFudFwiLFxuICBcIndlYnNpdGVcIlxuXSk7XG5mdW5jdGlvbiBpc1ZhbGlkRGF0ZShkYXRlU3RyaW5nKSB7XG4gIHJldHVybiAvXlxcZHs0fS1cXGR7Mn0tXFxkezJ9Ly50ZXN0KGRhdGVTdHJpbmcpID8gISFEYXRlLnBhcnNlKGRhdGVTdHJpbmcpIDogITE7XG59XG5mdW5jdGlvbiBpc1ZhbGlkVVJMKHVybCkge1xuICB0cnkge1xuICAgIG5ldyBVUkwodXJsLCB1cmwuc3RhcnRzV2l0aChcIi9cIikgPyBcImh0dHBzOi8vYWNtZS5jb21cIiA6IHZvaWQgMCk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiAhMTtcbiAgfVxuICByZXR1cm4gITA7XG59XG5jb25zdCBUUlVOQ0FURV9MRU5HVEggPSAyMDtcbmZ1bmN0aW9uIHN0ZWdhRW5jb2RlU291cmNlTWFwKHJlc3VsdCwgcmVzdWx0U291cmNlTWFwLCBjb25maWcpIHtcbiAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2k7XG4gIGNvbnN0IHsgZmlsdGVyLCBsb2dnZXIsIGVuYWJsZWQgfSA9IGNvbmZpZztcbiAgaWYgKCFlbmFibGVkKSB7XG4gICAgY29uc3QgbXNnID0gXCJjb25maWcuZW5hYmxlZCBtdXN0IGJlIHRydWUsIGRvbid0IGNhbGwgdGhpcyBmdW5jdGlvbiBvdGhlcndpc2VcIjtcbiAgICB0aHJvdyAoX2EgPSBsb2dnZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGxvZ2dlci5lcnJvcikgPT0gbnVsbCB8fCBfYS5jYWxsKGxvZ2dlciwgYFtAc2FuaXR5L2NsaWVudF06ICR7bXNnfWAsIHsgcmVzdWx0LCByZXN1bHRTb3VyY2VNYXAsIGNvbmZpZyB9KSwgbmV3IFR5cGVFcnJvcihtc2cpO1xuICB9XG4gIGlmICghcmVzdWx0U291cmNlTWFwKVxuICAgIHJldHVybiAoX2IgPSBsb2dnZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGxvZ2dlci5lcnJvcikgPT0gbnVsbCB8fCBfYi5jYWxsKGxvZ2dlciwgXCJbQHNhbml0eS9jbGllbnRdOiBNaXNzaW5nIENvbnRlbnQgU291cmNlIE1hcCBmcm9tIHJlc3BvbnNlIGJvZHlcIiwge1xuICAgICAgcmVzdWx0LFxuICAgICAgcmVzdWx0U291cmNlTWFwLFxuICAgICAgY29uZmlnXG4gICAgfSksIHJlc3VsdDtcbiAgaWYgKCFjb25maWcuc3R1ZGlvVXJsKSB7XG4gICAgY29uc3QgbXNnID0gXCJjb25maWcuc3R1ZGlvVXJsIG11c3QgYmUgZGVmaW5lZFwiO1xuICAgIHRocm93IChfYyA9IGxvZ2dlciA9PSBudWxsID8gdm9pZCAwIDogbG9nZ2VyLmVycm9yKSA9PSBudWxsIHx8IF9jLmNhbGwobG9nZ2VyLCBgW0BzYW5pdHkvY2xpZW50XTogJHttc2d9YCwgeyByZXN1bHQsIHJlc3VsdFNvdXJjZU1hcCwgY29uZmlnIH0pLCBuZXcgVHlwZUVycm9yKG1zZyk7XG4gIH1cbiAgY29uc3QgcmVwb3J0ID0ge1xuICAgIGVuY29kZWQ6IFtdLFxuICAgIHNraXBwZWQ6IFtdXG4gIH0sIHJlc3VsdFdpdGhTdGVnYSA9IGVuY29kZUludG9SZXN1bHQoXG4gICAgcmVzdWx0LFxuICAgIHJlc3VsdFNvdXJjZU1hcCxcbiAgICAoeyBzb3VyY2VQYXRoLCBzb3VyY2VEb2N1bWVudCwgcmVzdWx0UGF0aCwgdmFsdWUgfSkgPT4ge1xuICAgICAgaWYgKCh0eXBlb2YgZmlsdGVyID09IFwiZnVuY3Rpb25cIiA/IGZpbHRlcih7IHNvdXJjZVBhdGgsIHJlc3VsdFBhdGgsIGZpbHRlckRlZmF1bHQsIHNvdXJjZURvY3VtZW50LCB2YWx1ZSB9KSA6IGZpbHRlckRlZmF1bHQoeyBzb3VyY2VQYXRoLCByZXN1bHRQYXRoLCBmaWx0ZXJEZWZhdWx0LCBzb3VyY2VEb2N1bWVudCwgdmFsdWUgfSkpID09PSAhMSlcbiAgICAgICAgcmV0dXJuIGxvZ2dlciAmJiByZXBvcnQuc2tpcHBlZC5wdXNoKHtcbiAgICAgICAgICBwYXRoOiBwcmV0dHlQYXRoRm9yTG9nZ2luZyhzb3VyY2VQYXRoKSxcbiAgICAgICAgICB2YWx1ZTogYCR7dmFsdWUuc2xpY2UoMCwgVFJVTkNBVEVfTEVOR1RIKX0ke3ZhbHVlLmxlbmd0aCA+IFRSVU5DQVRFX0xFTkdUSCA/IFwiLi4uXCIgOiBcIlwifWAsXG4gICAgICAgICAgbGVuZ3RoOiB2YWx1ZS5sZW5ndGhcbiAgICAgICAgfSksIHZhbHVlO1xuICAgICAgbG9nZ2VyICYmIHJlcG9ydC5lbmNvZGVkLnB1c2goe1xuICAgICAgICBwYXRoOiBwcmV0dHlQYXRoRm9yTG9nZ2luZyhzb3VyY2VQYXRoKSxcbiAgICAgICAgdmFsdWU6IGAke3ZhbHVlLnNsaWNlKDAsIFRSVU5DQVRFX0xFTkdUSCl9JHt2YWx1ZS5sZW5ndGggPiBUUlVOQ0FURV9MRU5HVEggPyBcIi4uLlwiIDogXCJcIn1gLFxuICAgICAgICBsZW5ndGg6IHZhbHVlLmxlbmd0aFxuICAgICAgfSk7XG4gICAgICBjb25zdCB7IGJhc2VVcmwsIHdvcmtzcGFjZSwgdG9vbCB9ID0gcmVzb2x2ZVN0dWRpb0Jhc2VSb3V0ZShcbiAgICAgICAgdHlwZW9mIGNvbmZpZy5zdHVkaW9VcmwgPT0gXCJmdW5jdGlvblwiID8gY29uZmlnLnN0dWRpb1VybChzb3VyY2VEb2N1bWVudCkgOiBjb25maWcuc3R1ZGlvVXJsXG4gICAgICApO1xuICAgICAgaWYgKCFiYXNlVXJsKVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICBjb25zdCB7IF9pZDogaWQsIF90eXBlOiB0eXBlLCBfcHJvamVjdElkOiBwcm9qZWN0SWQsIF9kYXRhc2V0OiBkYXRhc2V0IH0gPSBzb3VyY2VEb2N1bWVudDtcbiAgICAgIHJldHVybiBiKFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAge1xuICAgICAgICAgIG9yaWdpbjogXCJzYW5pdHkuaW9cIixcbiAgICAgICAgICBocmVmOiBjcmVhdGVFZGl0VXJsKHtcbiAgICAgICAgICAgIGJhc2VVcmwsXG4gICAgICAgICAgICB3b3Jrc3BhY2UsXG4gICAgICAgICAgICB0b29sLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgcGF0aDogc291cmNlUGF0aCxcbiAgICAgICAgICAgIC4uLiFjb25maWcub21pdENyb3NzRGF0YXNldFJlZmVyZW5jZURhdGEgJiYgeyBkYXRhc2V0LCBwcm9qZWN0SWQgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIC8vIFdlIHVzZSBjdXN0b20gbG9naWMgdG8gZGV0ZXJtaW5lIGlmIHdlIHNob3VsZCBza2lwIGVuY29kaW5nXG4gICAgICAgICExXG4gICAgICApO1xuICAgIH1cbiAgKTtcbiAgaWYgKGxvZ2dlcikge1xuICAgIGNvbnN0IGlzU2tpcHBpbmcgPSByZXBvcnQuc2tpcHBlZC5sZW5ndGgsIGlzRW5jb2RpbmcgPSByZXBvcnQuZW5jb2RlZC5sZW5ndGg7XG4gICAgaWYgKChpc1NraXBwaW5nIHx8IGlzRW5jb2RpbmcpICYmICgoX2QgPSAobG9nZ2VyID09IG51bGwgPyB2b2lkIDAgOiBsb2dnZXIuZ3JvdXBDb2xsYXBzZWQpIHx8IGxvZ2dlci5sb2cpID09IG51bGwgfHwgX2QoXCJbQHNhbml0eS9jbGllbnRdOiBFbmNvZGluZyBzb3VyY2UgbWFwIGludG8gcmVzdWx0XCIpLCAoX2UgPSBsb2dnZXIubG9nKSA9PSBudWxsIHx8IF9lLmNhbGwoXG4gICAgICBsb2dnZXIsXG4gICAgICBgW0BzYW5pdHkvY2xpZW50XTogUGF0aHMgZW5jb2RlZDogJHtyZXBvcnQuZW5jb2RlZC5sZW5ndGh9LCBza2lwcGVkOiAke3JlcG9ydC5za2lwcGVkLmxlbmd0aH1gXG4gICAgKSksIHJlcG9ydC5lbmNvZGVkLmxlbmd0aCA+IDAgJiYgKChfZiA9IGxvZ2dlciA9PSBudWxsID8gdm9pZCAwIDogbG9nZ2VyLmxvZykgPT0gbnVsbCB8fCBfZi5jYWxsKGxvZ2dlciwgXCJbQHNhbml0eS9jbGllbnRdOiBUYWJsZSBvZiBlbmNvZGVkIHBhdGhzXCIpLCAoX2cgPSAobG9nZ2VyID09IG51bGwgPyB2b2lkIDAgOiBsb2dnZXIudGFibGUpIHx8IGxvZ2dlci5sb2cpID09IG51bGwgfHwgX2cocmVwb3J0LmVuY29kZWQpKSwgcmVwb3J0LnNraXBwZWQubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3Qgc2tpcHBlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICBmb3IgKGNvbnN0IHsgcGF0aCB9IG9mIHJlcG9ydC5za2lwcGVkKVxuICAgICAgICBza2lwcGVkLmFkZChwYXRoLnJlcGxhY2UocmVLZXlTZWdtZW50LCBcIjBcIikucmVwbGFjZSgvXFxbXFxkK1xcXS9nLCBcIltdXCIpKTtcbiAgICAgIChfaCA9IGxvZ2dlciA9PSBudWxsID8gdm9pZCAwIDogbG9nZ2VyLmxvZykgPT0gbnVsbCB8fCBfaC5jYWxsKGxvZ2dlciwgXCJbQHNhbml0eS9jbGllbnRdOiBMaXN0IG9mIHNraXBwZWQgcGF0aHNcIiwgWy4uLnNraXBwZWQudmFsdWVzKCldKTtcbiAgICB9XG4gICAgKGlzU2tpcHBpbmcgfHwgaXNFbmNvZGluZykgJiYgKChfaSA9IGxvZ2dlciA9PSBudWxsID8gdm9pZCAwIDogbG9nZ2VyLmdyb3VwRW5kKSA9PSBudWxsIHx8IF9pLmNhbGwobG9nZ2VyKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFdpdGhTdGVnYTtcbn1cbmZ1bmN0aW9uIHByZXR0eVBhdGhGb3JMb2dnaW5nKHBhdGgpIHtcbiAgcmV0dXJuIHRvU3RyaW5nKGpzb25QYXRoVG9TdHVkaW9QYXRoKHBhdGgpKTtcbn1cbnZhciBzdGVnYUVuY29kZVNvdXJjZU1hcCQxID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIHN0ZWdhRW5jb2RlU291cmNlTWFwXG59KTtcbmV4cG9ydCB7XG4gIHN0ZWdhRW5jb2RlU291cmNlTWFwJDEgYXMgYSxcbiAgZW5jb2RlSW50b1Jlc3VsdCBhcyBlLFxuICBzdGVnYUVuY29kZVNvdXJjZU1hcCBhcyBzXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RlZ2FFbmNvZGVTb3VyY2VNYXAuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@sanity/client/dist/_chunks/stegaEncodeSourceMap.js\n"));

/***/ })

}]);